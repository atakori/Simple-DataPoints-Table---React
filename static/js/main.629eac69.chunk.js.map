{"version":3,"sources":["api/index.js","components/LoadingScreen.js","components/Header.js","components/SegmentGroup.js","components/DataDetailsToolTip.js","components/Map.js","App.js","serviceWorker.js","index.js"],"names":["delay","value","duration","Math","round","random","Promise","resolve","window","setTimeout","LoadingScreen","props","id","className","fadeClass","src","alt","LoaderDots","theme","Header","initialLoadingComplete","calculateChronotopeDataPositionPercent","currentHitTime","Date","parse","chronotopeEarliestStartTime","chronotopeLatestStartTime","toString","SegmentGroup","useState","currentlyHovered","setHover","onMouseEnter","onMouseLeave","style","color","segmentColor","borderBottom","groupColor","borderTop","backgroundColor","segmentName","chronotopeData","map","dataPoint","key","message_id","currentDataMessageIdShown","left","hit_time","onClick","handleShowDataDetails","DataDetailsToolTip","dataDetails","hitTime","groupName","renderDetailsText","Map","state","mapData","segmentData","currentDataDetails","initialAjaxRunning","forEach","data","cooresepondingSegment","find","segment","segment_no","push","unorderedSegmentData","groupData","sortingRule","coorespondingGroup","group","group_no","group_position_no","position","group_hex_color","hex_color","group_name","name","orderedSegmentData","this","sortSegmentData","assignChronotopeDataToSegment","dataEarliestDate","dataLastestDate","currentDataHitTime","setState","sortedData","sort","a","b","all","segmentsData","groupsData","then","compileSegmentDataOrderedList","setChronotopeDataTimeSpan","messageId","dataProps","fetchAndSetInitialMapData","bind","React","Component","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.629eac69.chunk.js","sourcesContent":["import mapData from \"./map.json\";\nimport groupsData from \"./groups.json\";\nimport segmentsData from \"./segments.json\";\nimport chronotopeData from \"./chronotope.json\";\n\n/**\n * @template T\n * @param {T} value\n * @returns {Promise<T>}\n */\nfunction delay(value) {\n  const duration = Math.round(Math.random() * 3) + 2;\n  return new Promise((resolve) =>\n    window.setTimeout(resolve, duration * 1000, value)\n  );\n}\n\nexport function fetchMap() {\n  return delay(mapData);\n}\n\nexport function fetchSegments() {\n  return delay(segmentsData);\n}\n\nexport function fetchGroups() {\n  return delay(groupsData);\n}\n\nexport function fetchChronotopeData() {\n  return delay(chronotopeData);\n}\n","import React from 'react';\r\nimport { LoaderDots } from '@thumbtack/thumbprint-react';\r\n\r\n//Initial Loading Screen to be shown while Chronotope Data is initially complete\r\nconst LoadingScreen = (props) => {\r\n    return(\r\n        <div id=\"loading-screen-container\" className={props.fadeClass}>\r\n            <img id=\"loading-screen-img\" src='' alt=\"Please wait...\"/>\r\n            <LoaderDots theme=\"inverse\" />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default LoadingScreen;","import React from 'react';\r\n\r\nconst Header = (props) => {\r\n    return (\r\n            <div id=\"page-header\" className={props.initialLoadingComplete? \"show-visible-fade\" : \"hide-visible\"}>\r\n                {/* Image to go here */}\r\n                <img src=\"\" alt=\"Logo Here\"/>\r\n            </div>\r\n    )\r\n}\r\nexport default Header;","import React, { useState } from 'react';\r\n\r\n//Renders each segment row and its cooresponding chronotope data \r\nconst SegmentGroup = (props) => {\r\n    const [currentlyHovered, setHover] = useState(false);\r\n    \r\n    return (\r\n        <div onMouseEnter={() => setHover(true)} onMouseLeave={() => setHover(false)} className=\"segment\" style={{color: '#' + props.segmentColor, borderBottom: currentlyHovered? \"1px solid #\" + props.groupColor: \"\", borderTop: currentlyHovered? \"1px solid #\" + props.groupColor: \"\"}}>\r\n            <p className=\"segment-group-column\" style={{backgroundColor: '#' + props.groupColor, color: '#' + props.groupColor}}>|</p>\r\n            <p className=\"segment-name\">{props.segmentName}</p>\r\n            <div className= \"chronotope-data-container\">\r\n                {props.chronotopeData?.map(dataPoint => {\r\n                    return (\r\n                        <div key={dataPoint.message_id} className={\"chronotope-data \" + (props.currentDataMessageIdShown === dataPoint.message_id? \"highlight-node\": \"\")} style={{left: calculateChronotopeDataPositionPercent(dataPoint.hit_time, props)}} \r\n                        onClick={()=> props.handleShowDataDetails(dataPoint.hit_time, dataPoint.message_id, props)} > \r\n                            <span className=\"flex\"><span className=\"chronotope-node no-margin\" style={{backgroundColor: '#' + props.segmentColor}}></span></span>\r\n                        </div>\r\n                    )\r\n                })}\r\n            </div>\r\n        </div>\r\n    )\r\n} \r\n\r\n//calculates the position of each rendered segment data point\r\nfunction calculateChronotopeDataPositionPercent(currentHitTime, props) {\r\n    let percentage = (((Date.parse(currentHitTime) - props.chronotopeEarliestStartTime) / (props.chronotopeLatestStartTime - props.chronotopeEarliestStartTime)) * 100);\r\n    return percentage.toString() + '%';\r\n}\r\n\r\nexport default SegmentGroup;\r\n","import React from 'react';\r\n\r\n//Renders the specific details depending on what chronotope dataPoint is selected \r\n    //Child Component of Map.js\r\n\r\nconst DataDetailsToolTip = (props) => {\r\n    return (\r\n        <div id=\"toolTip-container\">\r\n            {renderDetailsText(props)}\r\n        </div>\r\n    )\r\n}\r\n\r\nfunction renderDetailsText(props) {\r\n    if(!props.dataDetails)\r\n        return (<div className=\"center-text full-width\">\r\n                    <p className=\"center-text\">Click a DataPoint above to view more details</p>\r\n                </div>)\r\n    else\r\n        return(<div id=\"toolTip-details-inner-container\">\r\n                    <p>Hit Time: {props.dataDetails.hitTime}</p>\r\n                    <p>Cluster: <span style={{color: '#'+ props.dataDetails.segmentColor}}>{props.dataDetails.segmentName}</span></p>\r\n                    <p>Group: <span style={{color: '#'+ props.dataDetails.groupColor}}>{props.dataDetails.groupName}</span></p>\r\n                </div>\r\n        )\r\n}\r\n\r\nexport default DataDetailsToolTip;","import React from 'react';\r\nimport * as api from \"../api/index\";\r\nimport LoadingScreen from './LoadingScreen';\r\nimport Header from './Header';\r\nimport SegmentGroup from './SegmentGroup';\r\nimport DataDetailsToolTip from './DataDetailsToolTip';\r\n\r\nclass Map extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            mapData: null,\r\n            segmentData: null,\r\n            chronotopeEarliestStartTime: null,\r\n            chronotopeLatestStartTime: null,\r\n            currentDataDetails: null,\r\n            initialAjaxRunning: true\r\n        };\r\n    }\r\n\r\n    //Sorts though all the chronotopeData and adds their data to the cooresponding segment that they belong to\r\n    assignChronotopeDataToSegment(segmentData, chronotopeData) {\r\n        chronotopeData.forEach(data => {\r\n            let cooresepondingSegment = segmentData.find(segment => segment.segment_no === data.segment_no);\r\n            \r\n            if(!cooresepondingSegment.chronotopeData)\r\n                cooresepondingSegment.chronotopeData = [];\r\n\r\n            cooresepondingSegment.chronotopeData.push(data);\r\n        })\r\n    }\r\n\r\n    //Creates an ordered segmentData object per the desired sorting rule\r\n    compileSegmentDataOrderedList(unorderedSegmentData, groupData, chronotopeData, sortingRule) {  \r\n        \r\n        //add cooresponding group data to segmentData\r\n        unorderedSegmentData.forEach(segment => {\r\n            let coorespondingGroup = groupData.find(group => {return segment.group_no === group.group_no})\r\n            \r\n            segment.group_position_no = coorespondingGroup.position;\r\n            segment.group_hex_color = coorespondingGroup.hex_color;\r\n            segment.group_name = coorespondingGroup.name;\r\n        })\r\n        \r\n        const orderedSegmentData = this.sortSegmentData(unorderedSegmentData, sortingRule);\r\n        this.assignChronotopeDataToSegment(orderedSegmentData, chronotopeData)\r\n    \r\n        return orderedSegmentData;\r\n    }\r\n\r\n    //loops through chronotope data and records the earliest and latest hit times \r\n    setChronotopeDataTimeSpan(chronotopeData) {\r\n        let dataEarliestDate = Date.parse(chronotopeData[0].hit_time);\r\n        let dataLastestDate = Date.parse(chronotopeData[0].hit_time);\r\n\r\n        chronotopeData.forEach(data => {\r\n            let currentDataHitTime = Date.parse(data.hit_time);\r\n\r\n            if(currentDataHitTime < dataEarliestDate) {\r\n                dataEarliestDate = currentDataHitTime;\r\n            }\r\n                \r\n            if(currentDataHitTime > dataLastestDate)\r\n                dataLastestDate = currentDataHitTime;\r\n        })\r\n\r\n        this.setState({\r\n            chronotopeEarliestStartTime : dataEarliestDate,\r\n            chronotopeLatestStartTime : dataLastestDate,\r\n        })\r\n    }\r\n\r\n    //Sorts Segment Data per the desired sorting rule\r\n    sortSegmentData(segmentData, sortingRule) {\r\n        let sortedData;\r\n\r\n        switch(sortingRule) {\r\n            case \"group_Asc,segment_Asc\":\r\n            default:\r\n                sortedData = segmentData.sort((a,b) => {\r\n                    return ((a.group_position_no - b.group_position_no) || (a.position - b.position))\r\n            })\r\n        }\r\n\r\n        return sortedData;\r\n    }\r\n    \r\n    //Fetches all the data and sets state for inital data render\r\n    fetchAndSetInitialMapData(){\r\n        Promise.all([api.fetchMap(),api.fetchSegments(),api.fetchGroups(),api.fetchChronotopeData()]).then(data => {\r\n            const orderedSegmentData = this.compileSegmentDataOrderedList(data[1], data[2], data[3]);\r\n            \r\n            this.setChronotopeDataTimeSpan(data[3]);\r\n            this.setState({\r\n                mapData: data[0],\r\n                segmentData: orderedSegmentData,\r\n                initialAjaxRunning: false\r\n            })\r\n        })\r\n    }\r\n    \r\n    //Compiles data details for the clicked dataPoint and updates the state\r\n    handleShowDataDetails(hitTime, messageId, dataProps) {\r\n        const dataDetails = {\r\n            messageId,\r\n            hitTime,\r\n            segmentName: dataProps.segmentName,\r\n            segmentColor: dataProps.segmentColor,\r\n            groupName: dataProps.groupName,\r\n            groupColor: dataProps.groupColor,\r\n        }\r\n\r\n        this.setState({\r\n            currentDataDetails: dataDetails\r\n        })\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.fetchAndSetInitialMapData();\r\n    }\r\n\r\n    render() {\r\n        return (\r\n        <div className={this.state.initialAjaxRunning? \"relative black-background\" : \"relative white-background-fadeIn\"}>\r\n            <LoadingScreen fadeClass={this.state.initialAjaxRunning? \"fade-in-opacity\" : \"fade-out-opacity\"}/>\r\n            <Header initialLoadingComplete={!this.state.initialAjaxRunning}/>\r\n            <div id=\"chronotope-map-section\" className={this.state.initialAjaxRunning? \"fade-out-opacity\" : \"fade-in-opacity\"}>\r\n                <h1 id=\"chronotope-map-title\">Chronotope Data for {this.state.mapData?.name}</h1>\r\n                <div id=\"chronotope-map-container\">\r\n                    {this.state.segmentData?.map(segment => {\r\n                        return (<SegmentGroup key={segment.id} segmentColor={segment.hex_color} groupColor={segment.group_hex_color} groupName={segment.group_name} segmentName ={segment.name}  \r\n                                    chronotopeData={segment.chronotopeData || null} chronotopeEarliestStartTime={this.state.chronotopeEarliestStartTime} \r\n                                    chronotopeLatestStartTime={this.state.chronotopeLatestStartTime} currentDataMessageIdShown={this.state.currentDataDetails?.messageId} \r\n                                    handleShowDataDetails={this.handleShowDataDetails.bind(this)}\r\n                                    />)\r\n                    })}\r\n                </div>\r\n                <DataDetailsToolTip dataDetails={this.state.currentDataDetails}/>\r\n            </div>\r\n        </div>\r\n            )\r\n    }\r\n}\r\n\r\nexport default Map;","import React from \"react\";\nimport \"./stylesheets/App.scss\";\nimport Map from './components/Map';\n\nfunction App() {\n  return (<div>\n      <Map />\n      </div>)\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}